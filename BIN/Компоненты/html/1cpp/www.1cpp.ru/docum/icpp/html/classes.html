<?xml version="1.0" encoding="CP1251" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from www.1cpp.ru/docum/icpp/html/classes.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 Mar 2024 08:56:53 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=CP1251" />
<meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" />
<title>Реализация ООП в 1С++</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: classes.html,v 1.1250 2013/01/30 23:11:09 fez Exp $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left{
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: left }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="id1">
<h1 class="title">Реализация ООП в 1С++</h1>

<!-- Автор: Александр Орефков -->
<!-- <chminfo>
        <insert nodes="//common/maininfo/*"/>
        <alinks>_1cpp_oop_</alinks>
</chminfo> -->
<div class="contents topic" id="id2">
<p class="topic-title first">Содержание</p>
<ul class="simple">
<li><a class="reference internal" href="#id3" id="id48">Введение</a></li>
<li><a class="reference internal" href="#id4" id="id49">Работа с компонентой</a><ul>
<li><a class="reference internal" href="#id5" id="id50">Состав компоненты</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6" id="id51">Функционал класса</a><ul>
<li><a class="reference internal" href="#id7" id="id52">ПолучитьБазовыйКласс</a></li>
<li><a class="reference internal" href="#id9" id="id53">ОтправитьСообщениеМодулюХоз</a></li>
<li><a class="reference internal" href="#id11" id="id54">ПолучитьПуть</a></li>
<li><a class="reference internal" href="#id13" id="id55">ПолучитьКонтекстОкружения</a></li>
<li><a class="reference internal" href="#id15" id="id56">ПолучитьСписокПараметров</a></li>
<li><a class="reference internal" href="#id17" id="id57">УстановитьПараметрПоИндексу</a></li>
<li><a class="reference internal" href="#id19" id="id58">ЗаменитьБазовыйОбъект</a></li>
<li><a class="reference internal" href="#id21" id="id59">_ПриОткрытии (устаревший)</a></li>
<li><a class="reference internal" href="#id23" id="id60">_ВыброситьИскл</a></li>
<li><a class="reference internal" href="#id27" id="id61">_ПолучитьКод</a></li>
<li><a class="reference internal" href="#sqlcreate" id="id62">_SQLCreate</a></li>
<li><a class="reference internal" href="#id30" id="id63">ЯвляетсяОбъектом</a></li>
<li><a class="reference internal" href="#id32" id="id64">Возможность использования класса-обработки и как класс и как обработку с формой</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id33" id="id65">Формат файла определения КОП</a></li>
<li><a class="reference internal" href="#id34" id="id66">Формат файлов реализации КОП</a><ul>
<li><a class="reference internal" href="#id35" id="id67">Краткое описание синтаксиса</a></li>
<li><a class="reference internal" href="#id36" id="id68">Обращение к методам/атрибутам класса из модуля класса</a></li>
<li><a class="reference internal" href="#id38" id="id69">Работа с базовыми классами</a></li>
<li><a class="reference internal" href="#id39" id="id70">Контроль установки/записи атрибутов</a></li>
<li><a class="reference internal" href="#id41" id="id71">Динамические атрибуты класса</a></li>
<li><a class="reference internal" href="#id43" id="id72">Сериализация экземпляров класса</a></li>
<li><a class="reference internal" href="#id44" id="id73">Возможность универсальной загрузки в любой объект класса:</a></li>
<li><a class="reference internal" href="#id45" id="id74">Примеры</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id46" id="id75">Препроцессор</a></li>
<li><a class="reference internal" href="#c" id="id76">Отладка классов 1C++</a></li>
<li><a class="reference internal" href="#id47" id="id77">Настройка 1C++</a></li>
</ul>
</div>
<div class="section" id="id3">
<h1>Введение</h1>
<!-- <chminfo split="0">
</chminfo> -->
<p>ООП - объектно-ориентированное программирование, является на сегодняшний день одной
из самых популярных технологий создания программных средств.
Данная разработка направлена на устранение недостатка отсутствия ООП в языке 1С.
Как известно, ООП базируется на трех основных принципах: полиморфизм, наследование
и инкапсуляция; в данной разработке для возможной технической реализации принципов,
были добавлены некоторые языковые средства.
Также добавлена возможность строгой проверки типов для параметров методов классов,
определяемых пользователем <em>(КОП)</em> и некоторые другие классы для расширения парадигмы ООП.</p>
<p><strong>Наследование</strong> - это обобщение объектов за счет выведения общего поведения в логически
связанных сущностях проекта. Возможность повторно использовать код и отделить
интерфейс объекта от его реализации с целью повышения взаимозаменяемости и
расширения частей системы без перепрограммирования и дополнительного тестирования
множества модулей. Наследование позволяет представить на логическим уровне модель
проектирования учетной системы более приближенно к проектируемой области.
Наследование необходимо реализовать для достижения следующих целей:</p>
<ul class="simple">
<li>уменьшение зависимостей не связанных между собой логически частей учетной системы;</li>
<li>уменьшение написания и тестирования кода для связанных между собой логически понятий
объектов системы</li>
<li>возможность расширения существующего функционала</li>
<li>концентрирование кода алгоритма в одном программном модуле с четко определенным
интерфейсом его использования, что позволит вносить изменения в алгоритм и осуществлять
его исправление без необходимости проверки и исправления всего зависящего от него кода</li>
<li>для разделения функционала на три логических уровня: уровень интерфейс пользователя,
уровень бизнес-логики, уровень сохранения/получения (персистентность) результатов и
объектов, другими словами - уровень взаимодействия с БД</li>
<li>повторяемость кода или наследуемость кода базового класса его наследниками</li>
</ul>
<p>В реализации наследования в ВК (внешней компоненте 1С:Предприятия) 1С++ необходимо
определить следующий функционал:</p>
<ul class="simple">
<li>Возможность наследования классов от встроенных типов, таких как: &quot;Справочник&quot;, &quot;Документ&quot; и т.д.</li>
<li>Возможность наследования от типов, определяемых пользователем (классов 1С++)</li>
<li>Возможность вызова переопределенных функций производными классами из функций базового класса</li>
<li>Возможность переопределения  функций базовых классов в классах наследниках</li>
<li>Возможность вызова базовых функций из переопределенных функций наследуемого класса</li>
</ul>
<p><strong>Полиморфизм</strong> - заключается в переопределении поведения объекта с помощью  специализации
обобщенного класса, т.е. переопределение методов интерфейсов базового класса (общий класс)
его наследником (более специализированным классом). Полиморфизм позволит:</p>
<ul class="simple">
<li>писать обобщенные алгоритмы для &quot;родственных&quot; объектов, находящихся в одной иерархии</li>
<li>добавлять новые классы в семейство логически связанных классов, уточняя и переопределяя
поведение, заявленное в более абстрактных базовых классах, без внесения изменения в код,
который использует интерфейс базового класса для взаимодействия с объектами одной иерархии</li>
<li>избавиться от кода, жестко завязанного на конкретные типы родственных объектов,
которые возможно расположить в единую иерархию наследования</li>
</ul>
<p><strong>Инкапсуляция</strong> - сокрытие деталей реализации классов за четко определенным интерфейсом.
Это позволит разрабатывать компоненты и настраивать их взаимодействие с меньшими
зависимостями между ними, что в свою очередь, уменьшит время тестирования и вероятность
появления ошибок в алгоритмах программы.</p>
</div>
<div class="section" id="id4">
<h1>Работа с компонентой</h1>
<div class="section" id="id5">
<h2>Состав компоненты</h2>
<ul class="simple">
<li>1C:Предприятие 7.7, релизы 14-27, Windows98 OSR2, Windows 2000, Windows XP, Windows 2003, Vista.</li>
<li>Файл движка ООП для 1С 1C++.dll, подключается с помощью метода 1С &quot;ЗагрузитьВнешнююКомпоненту(Путь)&quot;</li>
<li>Файл определения классов пользователя Defcls.prm, обязан находиться в каталоге информационной базы (ИБ)
в которой используются классы, определяемые пользователем компоненты.
Синтаксис языка определения классов см. ниже.</li>
<li>Файл oxy.ini, который необходимо создать в каталоге BIN 1C:Предприятия для настройки псевдонимов
путей к файлам реализации КОП.</li>
<li>Файлы реализации классов могут быть как в текстовом формате, так и в формате отчетов с расширением *.ert.
Имена файлов и привязки файлов реализации к классам задаются в файле определения Defcls.prm.</li>
</ul>
</div>
</div>
<div class="section" id="id6">
<h1>Функционал класса</h1>
<!-- <chminfo splitchild="0">
</chminfo> -->
<p>Каждый класс, определенный пользователем (КОП), создается в 1С с помощью метода СоздатьОбъект(ИмяКласса).</p>
<p>Для каждого КОП определен стандартный интерфейс, состоящий из следующих методов:</p>
<div class="section" id="id7">
<h2>ПолучитьБазовыйКласс</h2>
<p><span class="target" id="id8">ПолучитьБазовыйКласс</span> (ИмяБазовогоКласса) / GetBaseClass(strNameOfBaseClass)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Описание:</th><td class="field-body">возвращает объект базового класса для класса предка, имя которого передается в качестве строки в параметр метода
&quot;ИмяБазовогоКласса&quot;. Если объекта базового класса не существует, то метод возвратит 0.
Данный метод предназначен для вызова переопределенных методов базовых классов из методов
классов наследников и получения/установки атрибутов базовых классов.</td>
</tr>
<tr class="field"><th class="field-name">Пример:</th><td class="field-body">имеются следующие справочники: &quot;Необоротные активы&quot;, в котором содержатся общие
реквизиты всех необоротных активов предприятия, и справочники - спецификаторы, такие как
&quot;Основные средства&quot;, &quot;Нематериальные активы&quot;, которые, в свою очередь, добавляют
специфические реквизиты сущностей к общим реквизитам необоротных активов.
Исходя из описанной выше идеологии, мы строим следующую иерархию классов:
КОП с рабочим названием &quot;ОС&quot; наследует от классов 1С: справочника &quot;Необоротные активы&quot; и
&quot;Основные средства&quot; и переопределяет методы &quot;ВыбратьЭлементы()&quot; и &quot;ПолучитьЭлемент()&quot;,
т.к у КОП &quot;ОС&quot; базовые классы имеют такие же методы, программист обязан разрешить
неоднозначность вызова, воспользовавшись в реализации методов &quot;ВыбратьЭлементы()&quot; и &quot;ПолучитьЭлемент()&quot;
класса &quot;ОС&quot; методом ПолучитьБазовыйКласс(&quot;Основные средства&quot;) для вызова его функций
выборки и итераций и <a class="reference internal" href="#id8">ПолучитьБазовыйКласс</a> (&quot;Необоротные активы&quot;) для проведения аналогичных операций.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id9">
<h2>ОтправитьСообщениеМодулюХоз</h2>
<p><span class="target" id="id10">ОтправитьСообщениеМодулюХоз</span> (КтоОтправил, ВидСообщения, Данные)
/ SendMessageOwnMod(WhoSend, KindMessage, Data).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Описание:</th><td class="field-body">Вызывает предопределенную функцию ОбработкаСобытияОтКласса(отКого, стрСобытие, Данные),
реализованную в модуле, вызывающем работающий
в данный момент метод КОП, возвращает любое значение, которое будет получено после вызова
ОтправитьСообщениеМодулюХоз() в модуле КОП.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id11">
<h2>ПолучитьПуть</h2>
<p><span class="target" id="id12">ПолучитьПуть</span> () / GetPathName().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Описание:</th><td class="field-body">Возвращает полный путь и название файла, в котором хранится модуль реализации класса.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id13">
<h2>ПолучитьКонтекстОкружения</h2>
<p><span class="target" id="id14">ПолучитьКонтекстОкружения</span> () / GetEnvContext()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">Возвращаемое значение:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">Возвращает контекст, из которого получил управление модуль КОП</p>
</td>
</tr>
<tr class="field"><th class="field-name">Описание:</th><td class="field-body"><p class="first">Получить контекст окружения из модуля КОП.</p>
<p><strong>Метод считается устаревшим и оставлен только для совместимости.</strong></p>
</td>
</tr>
<tr class="field"><th class="field-name">Дополнение:</th><td class="field-body"><p class="first">Проблема метода ПолучитьКонтекстОкружения() в том, что класс получает контекст формы,
что-то с ним делает, а форма об этом ни сном, ни духом.
Причем ситуация усугубляется тем, что ПолучитьКонтекстОкружения() можно вызвать в каком-нибудь из базовых классов.
Или в классе может быть вызван метод другого класса, который и вызывает ПолучитьКонтекстОкружения().
Эту цепочку можно удлиннять и комбинировать.</p>
<p class="last">Таким образом, мы получаем ситуацию, когда теоретически любая форма может быть изменена в любом классе.
И найти, кто же и что нам поменял, можно только глобальным контекстным поиском.
Еще прочтите <a class="reference external" href="http://itland.ru/forum/index.php">http://itland.ru/forum/index.php</a>?showtopic=12465&amp;st=0&amp;p=65557&amp;#entry65557</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id15">
<h2>ПолучитьСписокПараметров</h2>
<p><span class="target" id="id16">ПолучитьСписокПараметров</span> (стрИмяМетода) / GetParamsList(strNameOfMeth)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">Возвращаемое значение:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">СписокЗначений с параметрами метода.</td>
</tr>
<tr class="field"><th class="field-name">Описание:</th><td class="field-body">Получить список со значениями неявных параметров, переданных в метод, название которого
необходимо передать в качестве параметра. Данный метод можно использовать только в теле
метода класса, который был определен с последним формальным параметром &quot;:&quot; в файле
определения КОП. Более подробное описание см. в пункте 1.3., раздел &quot;Неопределенное количество параметров&quot;.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id17">
<h2>УстановитьПараметрПоИндексу</h2>
<p><span class="target" id="id18">УстановитьПараметрПоИндексу</span> (стрИмяМетода&gt;,&lt;чИнд&gt;,&lt;нЗнач) /
SetOnIndexParams(strNameOfMeth &gt;,&lt;nInd&gt;,&lt;uVal)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Описание:</th><td class="field-body"><p class="first">Метод предназначен для получения ссылки
значения неявного параметра по его порядковому номеру и установке нового значения по данной ссылке.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Параметры:</th><td class="field-body"><ul class="first simple">
<li>стрИмяМетода - Имя метода ссылки на неявные параметры, которого необходимо получить.</li>
<li>чИнд - номер неявного параметра, ссылку на который надо получить и заменить</li>
<li>нЗнач - Новое значение.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Возврат:</th><td class="field-body"><p class="first last">1 - установка успешно произведена, 0 - произошла ошибка при установке</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id19">
<h2>ЗаменитьБазовыйОбъект</h2>
<p><span class="target" id="id20">ЗаменитьБазовыйОбъект</span> (стрИмяКласса&gt;, &lt;нЗначениеКласса) /
ReplaсeBaseObject(strNameClass&gt;, &lt;uValOfClass)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Описание:</th><td class="field-body"><p class="first">Предназначен для замены экземпляра
базового класса в уже созданной иерархии классов. Изменения базового класса отражаются только
на объекте, для которого был вызван данный метод.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Параметры:</th><td class="field-body"><ul class="first simple">
<li>стрИмяКласса - имя базового класса, экземпляр которого мы собираемся заменять.</li>
<li>нЗначениеКласса - новый экземпляр базового класса.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Возврат:</th><td class="field-body"><p class="first last">1- замена успешно произведена, 0 - произошла ошибка при замене</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id21">
<h2>_ПриОткрытии (устаревший)</h2>
<p><span class="target" id="id22">_ПриОткрытии</span> / _OnOpen - данный метод устарел и оставлен для совместимости.</p>
</div>
<div class="section" id="id23">
<h2>_ВыброситьИскл</h2>
<p><span class="target" id="id24">_ВыброситьИскл</span> (ОбъектИскл) / _Throw(Object)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Описание:</th><td class="field-body">формирует исключение с объектом- исключением.
Вызов этого метода в модуле КОП прекращает его выполнение и данное исключение передается дальше
в другие модули для поиска обработчика исключения (раскрутка стека). Если такой обработчик
не будет найден, то выполнение последнего модуля будет прекращено с выводом диагностического
сообщения в окно сообщений 1С. Получить объект &quot;Исключение&quot; можно с помощью метода
<a class="reference external" href="extobjs.chm__/extobjs31.html">ПолучитьИсключение</a> () дополнительного класса <a class="reference external" href="extobjs.chm__/extobjs16.html">ВыполняемыйМодуль</a> .</td>
</tr>
<tr class="field"><th class="field-name">Параметры:</th><td class="field-body">ОбъектИскл - любой объект 1С.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id27">
<h2>_ПолучитьКод</h2>
<p><span class="target" id="id28">_ПолучитьКод</span> () / _GetCode()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Описание:</th><td class="field-body">функция, которая должна вернуть строковое представление объекта;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sqlcreate">
<h2>_SQLCreate</h2>
<p><span class="target" id="id29">_SQLCreate</span> (Value, obMDW)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Описание:</th><td class="field-body"><p class="first">процедура, которую должен реализовать КОП для типизации значения
поля выборки объекта ODBCRecordset типом этого КОП (виртуальный конструктор).
Должна быть объявлена в модуле с ключевым словом Экспорт. Должна иметь два или меньше параметров.
Её вызывает объект ODBCRecordset при получении значения поля выборки, при типизации типом этого КОП.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Параметры:</th><td class="field-body"><ul class="first last simple">
<li>Value - значение поля выборки без типизации;</li>
<li>obMDW - статический объект типа MetaDataWork.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id30">
<h2>ЯвляетсяОбъектом</h2>
<p><span class="target" id="id31">ЯвляетсяОбъектом</span> (ИмяПроверяемогоТипа) / _IsObject(ИмяПроверяемогоТипа)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Параметры:</th><td class="field-body"><ul class="first simple">
<li>ИмяПроверяемогоТипа. тип: Строка.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Описание:</th><td class="field-body"><p class="first last">Функция, которая проверяет, является ли данный объект класса указанным
типом или производным от этого типа.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id32">
<h2>Возможность использования класса-обработки и как класс и как обработку с формой</h2>
<p>Для включения подобной возможности необходимо использовать специальную
переменную препроцессора _NOW_PREPARE_CLASS</p>
<p>Примерный код подобного класса выглядит след.образом</p>
<pre class="literal-block">
//#if _NOW_PREPARE_CLASS
  // -- данные и методы класса
//#endif //_NOW_PREPARE_CLASS

//#if !_NOW_PREPARE_CLASS
  // -- данные и процедуры формы

  Процедура ПриОткрытии()
  // код открытия формы
  КонецПроцедуры
//#endif  //! _NOW_PREPARE_CLASS
</pre>
</div>
</div>
<div class="section" id="id33">
<h1>Формат файла определения КОП</h1>
<p>Файл определения классов должен быть расположен в одном каталоге с файлом конфигурации и
называться <strong>Defcls.prm</strong>, если файла с таким именем не обнаружено, ВК осуществляет поиск
в текущей конфигурации обработки с именем Defcls. Синтаксис языка определения классов следующий:</p>
<pre class="literal-block">
// - комментарий для программы
класс (class)  имя класса = имя файла класса реализации :
  &lt;имя базового класса&gt;, &lt;имя базового класса&gt; {
Объявления методов класса
};
</pre>
<dl class="docutils">
<dt><strong>имя класса</strong></dt>
<dd>может состоять из любых печатных символов. Внимание! учитывается регистр имени.</dd>
<dt><strong>имя файла</strong></dt>
<dd>&lt;Путь&gt;|&lt;#Псевдоним&gt;Имя файла.* | Имя обработки&#64;MD файл реализации класса, если не указан путь,
расположенный в каталоге с файлом конфигурации текущей ИБ, в котором реализуются методы класса
и определяются атрибуты. Путь может быть относительным и формируется всегда относительно пути
расположения конфигурации ИБ, вне зависимости от текущей папки файловой системы. Если указан
#Псевдоним пути, то данный псевдоним ищется в файле инициализации компоненты, который должен
находиться в каталоге BIN 1С:Предприятия и называться oxy.ini. В данном файле необходимо создать
раздел [alias_path], который содержит все псевдонимы путей.</dd>
</dl>
<p>Текст КОП возможно хранить в конфигурации в виде обработок, для этого необходимо указать имя
обработки и прибавить окончание &#64;MD, с соблюдением регистра букв у окончания.</p>
<p>Пример файла инициализации компоненты:</p>
<pre class="literal-block">
[alias_path]
Псевдоним1 = С:\Классы1С_1\
Псевдоним2 = С:\Классы1С_2\
</pre>
<p>Далее в файле определения пути к классам необходимо написать следующее:</p>
<pre class="literal-block">
класс МойКласс = #Псевдоним1\ Псевдоним1.ert {};
</pre>
<dl class="docutils">
<dt><strong>имя базового класса</strong></dt>
<dd>базовые классы класса <strong>имя класса</strong>. Базовые классы могут отсутствовать или их может быть несколько,
тогда они разделяются запятой.</dd>
<dt><strong>объявление методов класса</strong></dt>
<dd>функции и процедуры. Необязательно определять все функции, а только те, для которых необходимы
проверка типов, определение  параметров по умолчанию, неявные параметры и передача параметров
по значению. (все, что указано в угловых скобочках - опциональные элементы, без них -
обязательные элементы)</dd>
<dt>функции:</dt>
<dd>&lt;Тип возвращаемого значения&gt; Имя функции (Val | Знач&gt; Тип
переменной &lt;Имя переменной = Значение по умолчанию&gt;, &lt;Val | Знач&gt; Тип
переменной &lt;Имя переменной&gt;, ...);</dd>
<dt>процедуры:</dt>
<dd>void Имя процедуры (Val | Знач&gt; Тип переменной Имя
переменной = Значение по умолчанию, &lt;Val | Знач&gt; Тип переменной &lt;Имя
переменной&gt;, ...);</dd>
<dt>Val | Знач</dt>
<dd>предопределенное слово, означает, что параметр метода
передается по значению, т.е. в методе используется копия переданного параметра.
(необязательный)</dd>
</dl>
<p>Любой <strong>тип</strong> - может быть заменен ключевым словом Неопределенный
(Undefine), что отключает для данного параметравозвращаемого значения
проверку типов. Типом может быть Справочник, что означает возможность
передавать в параметр метода справичник любойго вида справочника,
(аналогичное поведение для типов Документ, и Регистр, и т.п.) - смысл,
аналогичный типу &quot;Справочник&quot; или ГрупповойКонтекст, когда типом параметра
может быть контекст любого модуля. (обязательный)</p>
<dl class="docutils">
<dt>Имя</dt>
<dd>формального параметра метода. Обязательно должен быть указано при
определении значения по умолчанию, во всех остальных случаях - необязателено.</dd>
<dt>Значение по умолчанию</dt>
<dd>задается после имени параметра и должно быть
одного того же типа, что и тип для данного параметра. Возможные типы: Строка
Пар1 = &quot;Значение по умолчанию&quot;; Число Пар1 = 100; Дата Пар1 = '01.01.2002', а
также КОП и агрегатные объекты 1С:Предприятия задаются с заключением их в
кавычки, например МойКласс ПарКласс = &quot;МойКласс&quot; - по умолчанию параметр
ПарКласс будет содержать в теле метода значение экземпляра класса &quot;МойКласс&quot;.
Значением по умолчанию может быть простое выражение языка 1С, например -
значения констант, перечислений, функций без параметров. Например, Дата
дПарДата = РабочаяДата(), параметр &quot;дПарДата&quot; примет значение по умолчанию,
возвращенное из метода  РабочаяДата(). Внимание: при указании в качестве
значения по умолчанию &quot;&quot; - тип значения не учитывается. Значения по умолчанию
возможно задать только в последних параметрах метода.
<strong>Также возможно задавать параметры по умолчанию прямо в модулях определения класса,
а не в prm-файле, т.е. как в штатном 1С.</strong> Но есть ограничения:
1. Приоритет будет у определения в prm-файле
2. Для  параметров,  определенных  в  модулях  классов,  действуют   штатные
ограничения 1С на параметры по-умолчанию - например, нельзя использовать
функции и т.д.
3. Методы с неопределенным числом параметров можно описывать только в прм-файлах.</dd>
<dt>Неопределенное количество параметров</dt>
<dd>метод, объявленный с
параметром &quot;...&quot;, может принимать любое количество параметров во время вызова.
Параметры метода, которые определены стандартным образом, называются
явными параметрами. Параметры, которые получены в ходе вызова метода в
месте определения троеточия и далее за ним, называются <strong>неявными</strong>. Пример: void
Метод1(Строка стрПар1, Число чПар2, ...);, где параметры стрПар1, чПар2
являются явными и при вызове метода в них обязательно необходимо передавать
значения их типов. Пример вызова данного метода может выглядеть так:
МойКласс.Метод1(&quot;{Пар3, Пар4, Пар5}&quot;, 200, &quot;Значение параметра 3&quot;, &quot;Значение
параметра 4&quot;, &quot;Значение параметра 5&quot;); , где значения неявных параметров равны
следующим строкам &quot;Значение параметра 3&quot;, &quot;Значение параметра 4&quot;, &quot;Значение
параметра 5&quot;, количество таких значений в нашем примере равно 3, но оно может
быть любым и зависит только от потребностей алгоритма. И в то же время явные
параметры стрПар1 и чПар2 в нашем примере, соответственно, получат значения
&quot;{Пар3, Пар4, Пар5}&quot; и 200. В реализации метода &quot;Метод1&quot;  необходимо написать
процедуру со следующей сигнатурой: Процедура Метод(стрПар1, чПар2) //Тело
процедуры КонецПроцедуры. Значения неявных параметров можно получить
вызвав общий метод класса <a class="reference internal" href="#id16">ПолучитьСписокПараметров</a> (ИмяМетода)
(GetParamsList(NameOfMethod)), который возвращает список значений,
содержащий неявные значения параметров, переданных в метод. В одном из явных
параметров Вы можете передать строку, заключенную в фигурные скобки ({}), и
содержащую названия ключей, разделенных запятыми. Данные ключи
сопоставляются с неявными параметрами в списке значений, которые в реализации
метода класса можно получить, использовав метод списка &quot;Получить(Строка)&quot;. В
нашем примере таким строковым (явным) параметром является первый параметр
метода &quot;стрПар1&quot;, значение которого при вызове метода равно &quot;{Пар3, Пар4,
Пар5}&quot;, что означает - в списке значений неявных параметров содержатся
значения &quot;Значение параметра 3&quot;, строковый ключ которого равен &quot;Пар3&quot;,
следующее значение &quot;Значение параметра 4&quot;, а ключ для него &quot;Пар4&quot; и т.д.</dd>
</dl>
<p>Примеры:</p>
<pre class="literal-block">
класс Базовый_1=Base_1.txt
{
  void Метод1(Число пар1, Строка пар2);
  Число Метод2(Число пар1, Дата пар2);
};
класс Производный_1=Derive_1.txt: Базовый_1, Справочник.Спр1, ТаблицаЗначений
{
  void Метод1(Число пар1, Строка пар2); // Данный метод переопределяет метод
    //базового класса
  Число КоличествоСтрок (Число Колич); // В данном случае мы переопределили
    //метод базового класса ТаблицаЗначений и добавили проверку типов. В реализации этого
    //метода можно переадресовать вызов базовому классу
  void Метод3(ОС ОС); // в этот метод мы должны передаем передавать КОП &quot;ОС&quot;
};
класс ОС=OC.txt : Справочник.ОсновныеСредства, Справочник.НематериальныеАктивы
{
  void Метод1(Базовый_1 пар1); // В данном случае в пар1 можно передавать
    //объекты типа &quot;Базовый_1&quot; и его производный класс &quot;Производный_1&quot;
  void Метод2(Производный_1 пар1); // в отличие от предыдущего случае в пар1 мы
    //можем передавать объекты типа &quot;Производный_1&quot;, но не &quot;Базовый_1&quot;
  Число ВыбратьЭлементы(Число чРежим);
  Число ПолучитьЭлемент(Число чРежим);
};
</pre>
<p>Внимание: проверка типов может быть отключена по требованию пользователя, об этом
см. ниже.</p>
</div>
<div class="section" id="id34">
<h1>Формат файлов реализации КОП</h1>
<div class="section" id="id35">
<h2>Краткое описание синтаксиса</h2>
<p>Для каждого КОП необходим отдельный файл реализации (как текстовый, так
и отчет 1С), расположенный в каталоге БД или в папке, указанной в определении имени
файла класса, либо в папке, указанной в псевдониме пути. С именем класса связывается
файл реализации КОП в файле определения Defcls.prm.</p>
<p>Синтаксис языка файла реализации КОП полностью соответствует
синтаксису языка 1С:Предприятия, плюс возможно использовать препроцессорные
директивы.</p>
<p>Открытые атрибуты КОП определяются как общие переменные в модуле с
ключевым словом <em>Экспорт</em>.</p>
<p>Закрытые атрибуты КОП определяются как общие переменные в модуле без
ключевого слова <em>Экспорт</em>.</p>
</div>
<div class="section" id="id36">
<h2>Обращение к методам/атрибутам класса из модуля класса</h2>
<p><em>Обращение к методам компоненты из файла реализации КОП (модуля
КОП), таких таким как: `ПолучитьБазовыйКласс`_ ,
или обращение к виртуальным (экспортным) методам и атрибутам
осуществляется через метод</em> <strong>вирт()</strong> . Пример:</p>
<pre class="literal-block">
// Реализация метода &quot;Метод1&quot; класса &quot;Производный_1&quot; см. предыдущий пример
Процедура Метод1 (пар1, пар2) Экспорт
  Базовый_1 = вирт().ПолучитьБазовыйКласс(&quot;Базовый_1&quot;);
  Если Базовый_1 &lt;&gt; 0 Тогда

  КонецЕсли;
КонецПроцедуры

Процедура Метод2 () Экспорт
  вирт().Метод1(1, 2);
КонецПроцедуры
</pre>
<p id="id37"><em>Также есть возможность обращения к виртуальным (экспортным) методам и
атрибутам класса без использования виртуальности с помощью метода</em> <strong>Я()</strong>
Например, см. <a class="reference internal" href="#id40">ДинамическиеАтрибуты</a></p>
<p>Примеры использования вирт() и я() см. по адресам
<a class="reference external" href="http://www.1cpp.ru/forumfiles/Attachments/1cpp_test_virt_2.rar">http://www.1cpp.ru/forumfiles/Attachments/1cpp_test_virt_2.rar</a></p>
<p>или в конфигурации юнит-тестов 1С++ - класс ООПТесты::Тест_Вирт...</p>
<p>Также подробная инфа о вирт() и я() есть в ветке на форуме 1С++
<a class="reference external" href="http://www.1cpp.ru/forum/YaBB.pl?num=1207661901/0">http://www.1cpp.ru/forum/YaBB.pl?num=1207661901/0</a></p>
<p><em>Старый вариант, оставленный для совместимости:</em>
Обращение к методам компоненты из файла реализации КОП (модуля
КОП), таких таким как: <a class="reference internal" href="#id8">ПолучитьБазовыйКласс</a> ,
осуществляется через Контекст данного модуля. Пример:</p>
<pre class="literal-block">
// В начале каждого модуля приходится определять закрытую функцию для получения
// контекста. Поэтому лучше пользоваться вирт() !
Функция Этот(Конт) Возврат Конт; КонецФункции

// Реализация метода &quot;Метод1&quot; класса &quot;Производный_1&quot; см. предыдущий пример
Процедура Метод1 (пар1, пар2) Экспорт
  Конт = Этот(Контекст);
  Базовый_1 = Конт.ПолучитьБазовыйКласс(&quot;Базовый_1&quot;);
  Если Базовый_1 &lt;&gt; 0 Тогда

  КонецЕсли;
КонецПроцедуры
</pre>
<div class="attention">
<p class="first admonition-title">Attention!</p>
<p>Предупреждение: нельзя сохранять контекст класса в его
атрибуте, т.е. запрещен следующий алгоритм:</p>
<pre class="last literal-block">
Перем Конт;
...............
Конт = вирт();
...............
</pre>
</div>
<div class="attention">
<p class="first admonition-title">Attention!</p>
<p>или:</p>
<pre class="literal-block">
Перем Конт;
Функция GetThis(Конт) Возврат Конт; КонецФункции
...............
Конт = GetThis(Контекст);
...............
</pre>
<p class="last">Если Вы будете использовать такое присваивание, объекты класса, созданные Вами
в алгоритмах с помощью конструкции СоздатьОбъект(&quot;ИмяКлассаКОП&quot;), никогда
не уничтожатся (memory leaks), из-за циклической ссылки на объект внутри модуля
реализации КОП. Это замечание также справедливо и для взаимных ссылок, когда
один экземпляр класса содержит в себе ссылку на другой, и этот другой, в свою
очередь, имеет ссылку на первый.</p>
</div>
<p>В каждой реализации класса можно создать процедуры <strong>Конструктор</strong> () англ.
Constructor() и <strong>Деструктор</strong> () англ. Destructor(), которые вызываются, соответственно, в
моменты создания экземпляра класса и его уничтожения (Конструктор() - объект создан,
Деструктор() - объект уничтожен). Реализация данных процедур не обязательна.</p>
</div>
<div class="section" id="id38">
<h2>Работа с базовыми классами</h2>
<p>В базовых классах иерархии возможно вызывать открытые методы
производных классов (объявленные с ключевым словом &quot;Экспорт&quot;),
воспользовавшись для этого контекстом модуля базового класса ( вирт().Метод() ), также с помощью
контекста возможно получить название конечного созданного класса ( ТипЗначенияСтр(вирт() ).</p>
</div>
<div class="section" id="id39">
<h2>Контроль установки/записи атрибутов</h2>
<p>Для контроля установки/записи атрибутов необходимо определить
предопределенные методы (Процедура) в модуле реализации КОП (слово Экспорт к
данным методам применять не обязательно):</p>
<ul class="simple">
<li>При чтении атрибута класса вызывается метод
<strong>ПриПолучении_ИмяАтрибута</strong> (ЗначениеАтрибута) англ. OnGet_, где
ИмяАтрибута - имя атрибута, определенного в модуле КОП, из которого
выполняют считывание, в переменную ЗначениеАтрибута нужно вернуть
текущее значение атрибута.</li>
<li>При записи в атрибут класса вызывается метод
<strong>ПриЗаписи_ИмяАтрибута</strong> (ЗначениеДляУст) англ. OnWrite_, где
ИмяАтрибута - имя атрибута, определенного в модуле КОП, для которого
устанавливают значение, передаваемое в параметре ЗначениеДляУст.
Атрибут доступен в коде данного метода, и для его установки необходимо
присвоить атрибуту полученный параметр метода. Данный метод не
изменяет состояние самого атрибута по умолчанию.</li>
</ul>
</div>
<div class="section" id="id41">
<span id="id40"></span><h2>Динамические атрибуты класса</h2>
<ul>
<li><p class="first">Динамические атрибуты класса реализуются следующим образом:</p>
<ul class="simple">
<li>Класс должен самостоятельно добавить динамическое свойство с помощью встроенного метода КОП <strong>ДобавитьДинамическоеСвойство</strong> (стрИмяНовогоСвойства)</li>
</ul>
<p><strong>Внимание</strong>: вызов метода ДобавитьДинамическоеСвойство необходимо производить не через Сам(Контекст) или вирт(),
а с помощью спец.метода КОП <a class="reference internal" href="#id37">Я</a> - Я().ДобавитьДинамическоеСвойство. Иначе невозможно будет обратиться к методу базового класса, вызывающего данный код из метода класса-наследника.</p>
<ul>
<li><p class="first">в классе необходимо определить 2 предопределенных метода класса:</p>
</li>
<li><p class="first">При чтении динамического атрибута класса вызывается</p>
<p>предопределенная функция <strong>_ПриЧтенииСвойства</strong> (стрИмяСвойства) англ.
_OnReadProperty(strNameOfProperty) в параметр &quot;стрИмяСвойства&quot;
передается название атрибута, как оно было указано в вызывающем
коде. Возвращать данный метод обязан значение считанного
атрибута с названием, полученным из параметра метода
&quot;стрИмяСвойства&quot;.</p>
</li>
<li><p class="first">При установке значения атрибута экземпляра класса вызывается
предопределенная процедура
<strong>_ПриЗаписиСвойства</strong> (стрИмяСвойства,  НовоеЗначениеАтриб),
где &quot;стрИмяСвойства&quot; - имя записываемого свойства, а в
параметре &quot;НовоеЗначениеАтриб&quot; содержится новое значение
атрибута, т.е. правая часть выражения присваивания нового значения
свойству класса.</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul class="simple">
<li>Пример использования <a class="reference external" href="http://www.1cpp.ru/forum/YaBB.pl?num=1223885925/10#10">ВеткаПоДинамическимАтрибутам</a></li>
</ul>
</blockquote>
</div>
<div class="section" id="id43">
<h2>Сериализация экземпляров класса</h2>
<p>Экземпляры создаваемых классов можно сохранять в строку, а затем
восстанавливать из неё (сериализация КОП). Для этого в классе необходимо
определить следующие методы:</p>
<ol class="arabic simple">
<li>IsSerializable() рус. <strong>КлассСохраняемый</strong> () /Функция/, метод должен
возвращать 1, если класс может быть восстановлен или записан в строку.</li>
<li>SaveToString() рус. <strong>СохранитьКлассВСтроку</strong> () /Функция/, метод должен
возвращать строку, по которой потом можно будет восстановить состояние
экземпляра класса.</li>
<li>LoadFromString(str) рус. <strong>ЗагрузитьИзСтроки</strong> (стр) /Процедура/, в данный
метод передается строка ранее полученная из метода
&quot;СохранитьКлассВСтроку()&quot;, по которой можно восстановить состояние
класса, существовавшее на момент сохранения. Важно: при подобном
создании объекта его встроенный конструктор не вызывается, разработчик
класса должен самостоятельно инициализировать полученный объект в
методе ЗагрузитьИзСтроки.</li>
</ol>
<p>Если в классе реализован метод &quot;КлассСохраняемый()&quot;, который возвращает
значение, не равное 0, и реализован метод СохранитьКлассВСтроку(), то при
использовании функции 1С ЗначениеВСтрокуВнутр(ЭкзКласса) вернет строку,
сформированную в классе методом &quot;СохранитьКлассВСтроку()&quot;.</p>
<p>Для восстановления классов КОП, поддерживающих сериализацию,
необходимо, как обычно в 1С, использовать встроенную функцию 1С &quot;ЗначениеИзСтрокиВнутр&quot;
Например,
СериализованноеПредставление = ЗначениеИзСтрокиВнутр(Объект);
Объект = 0;
Объект = ЗначениеИзСтрокиВнутр(СериализованноеПредставление);</p>
</div>
<div class="section" id="id44">
<h2>Возможность универсальной загрузки в любой объект класса:</h2>
<p>Для реализации универсального интерфейса загрузки КОП должен
определить 5 методов
Число СобытиеЗагрузки_НачалоЗагрузки(КолвоКолонок, КолвоСтрок)
Число СобытиеЗагрузки_ДобавитьКолонку(ИмяКолонки, НомерТипа)
Число СобытиеЗагрузки_ДобавитьДанные(Вектор)
Число СобытиеЗагрузки_ОкончаниеЗагрузки()
Строка СобытиеЗагрузки_СообщениеОбОшибке()</p>
<p>Необходимо реализовать все 5 методов, иначе будет выдана ошибка.
После реализации подобных методов для объектов данного класса можно будет
выполнить универсальную выгрузку из различных контейнеров, например, ИТЗ,
Вектор/АссоциативныйВектор и др.коллекции - ИТЗ.Выгрузить(ОбъектКОП).</p>
<p>Более подробно см. ветку <a class="reference external" href="http://www.1cpp.ru/forum/YaBB.pl?num=1216110955/0">http://www.1cpp.ru/forum/YaBB.pl?num=1216110955/0</a></p>
</div>
<div class="section" id="id45">
<h2>Примеры</h2>
<p><strong>Примеры</strong>:
Иерархия классов выглядит так:</p>
<pre class="literal-block">
class База = base.ert
{
        void Метод1(); // Этот метод мы не переопределяем, а вызываем здесь
                                                                          // Метод2 производного класса
        void Метод2();
};
class Производный = derive.ert : Тест14_База
{
        void Метод2(); // переопределяем метод базового класса
};
</pre>
<p>Модуль реализации класса &quot;База&quot;:</p>
<pre class="literal-block">
Процедура Метод2() Экспорт
        Сообщить(&quot;База::Метод2&quot;);
КонецПроцедуры
Процедура Метод1() Экспорт
        Сообщить(&quot;ТипзначенияСтр(Контекст) =
&quot;+ТипзначенияСтр( вирт() )); // получаем название текущего класса
        вирт().Метод2(); // вызываем переопределенный метод
КонецПроцедуры
</pre>
<p>Модуль реализации класса &quot;Производный&quot;:</p>
<pre class="literal-block">
Процедура Метод2() Экспорт
        Сообщить(&quot;Производный::Метод2&quot;);
КонецПроцедуры
</pre>
<p>Модуль:</p>
<pre class="literal-block">
Сообщить(&quot;Создали Производный класс&quot;);
копПрозв = СоздатьОбъект(&quot;Производный&quot;);
копПрозв. Метод1();
Сообщить(&quot;Создали База класс&quot;);
копБаза = СоздатьОбъект(&quot;База&quot;);
копБаза. Метод1();
</pre>
<p>Вывод на экран будет следующим:</p>
<pre class="literal-block">
Создали Производный класс
Производный
Производный::Метод2
Создали База класс
База
База::Метод2
</pre>
<p>В одном модуле можно хранить код нескольких классов. Для этого
необходимо код каждого класса заключить в следующие скобки:</p>
<pre class="literal-block">
//# ClassBegin &lt;ClassName1&gt;;
Перем ПеременнаяКласса1;
Процедура Конструктор()
        .........
//# ClassEnd &lt;ClassName1&gt;;



//# ClassBegin &lt;ClassName2&gt;;
Перем ПеременнаяКласса2;
Процедура Конструктор()
        .........
//# ClassEnd &lt;ClassName2&gt;;
</pre>
<p>Где вместо &lt;ClassName1&gt; нужно указать имя класса (без угловых скобок).
Наличие пробела после # и ClassBegin обязательно. Также обязательно наличие ; сразу после имени класса.
Ограничения:</p>
<ul class="simple">
<li>Текст одного класса обязательно должен идти одним куском.</li>
<li>Штатный синтаксис-контроль подобных модулей в Конфигураторе не работает без плагина Visual1C++.</li>
<li>Формирование ALS-файлов для таких классов - невозможно.</li>
</ul>
</div>
</div>
<div class="section" id="id46">
<h1>Препроцессор</h1>
<p>Директивы препроцессора 1С++ могут быть в файлах объявления интерфейсов классов
(Defcls.prm), в файлах реализации КОП и во всех модулях 1С, кроме модуля глобального
модуля и модулей внешних обработок/отчетов. Символы препроцессора, объявленные в
файле объявления класса, действительны в области видимости модулей реализации
класса, т.е. доступны в файлах реализации КОП. Внимание: из-за раздельной
интерпретации файла Defcls.prm и файлов реализации КОП изменения, определения и
отключение символов препроцессора осуществляются независимо. Работа препроцессора
гарантируется в следующей последовательности: сначала обрабатывается файл
Defcls.prm, затем в неопределенной последовательности обрабатываются файлы
реализации КОП.</p>
<!-- Attention: Все директивы препроцессора должны начинаться с новой
строки и тело ее не должно переноситься на следующую строку. -->
<dl class="docutils">
<dt>//#if symbol [operator symbol]</dt>
<dd><p class="first">Если символ определен, что равнозначно &quot;истине&quot;,
или символы, объединённые логическими операторами дают в результате
&quot;истину&quot;, то код, заключенный между директивами //#if  и //#elif  или  //#else или
//#endif, буден включен на выполнение.
Symbol - это символ, который будет тестироваться на определенность ранее
директивой //#define. Перед символом можно использовать знак ! (логическое
отрицание).
Operator:</p>
<pre class="literal-block">
=  (равно);
!=  (не равно);
&amp;   (И);
\|   (ИЛИ);
</pre>
<p class="last">тело с кодом, открытое директивой //#if, должно закрываться директивами //#elif ,
//#else, //#endif;</p>
</dd>
<dt>//#else</dt>
<dd>директива, тело которой получает управление, если выражение равно
&quot;ложь&quot; в предшествующих ей директивах //#if или //#elif. Тело с кодом должно
заканчиваться директивой //#endif;</dd>
<dt>//#elif symbol [operator symbol]</dt>
<dd>директива, управление на которую передается,
если в предыдущих директивах //#elif и //#if была получена &quot;ложь&quot;. Проверяются
условия указанные symbol [operator symbol]... и, если получена &quot;истина&quot;, код
заключенный в блоке между //#elif, и следующим за ним директивой //#elif или
#else или //#endif, включается в код модуля КОП. Описание symbol [operator
symbol]... см. у директивы //#if;</dd>
<dt>//#define symbol</dt>
<dd>определяет символ условной компиляции, использование этого
символа в условных директивах даст &quot;истину&quot;, с условием отсутствия снятия этого
символа ранее директивой //#undef;</dd>
<dt>//#undef symbol</dt>
<dd>убирает определенный ранее символ. Символ используется для
условной интерпретации  кода в директивах //#if, //#elif, //#else;</dd>
<dt>//#warning text</dt>
<dd>выводит &quot;text&quot; в окно сообщений 1С. Примечание: в Defcls.prm
данная директива отключена;</dd>
<dt>//#error text</dt>
<dd>останавливает выполнение кода программы в этом месте с выводом
&quot;text&quot; в окно сообщений 1С. Примечание: в Defcls.prm данная директива
отключена;</dd>
<dt>//#preprocessor off</dt>
<dd>данная директива должна располагаться в первой строке
модуля и служит для выключения препроцессорной обработки кода модуля.</dd>
<dt>//#exinfo</dt>
<dd>данная директива может быть использована только в модулях
реализации КОП. Директива выводит информацию пользователю о месте вызова
метода, в котором она расположена, и строку кода, который осуществил вызов
метода. В основном используется в отладочных целях.</dd>
<dt>#include &quot;&lt;#alias&gt;&lt;/pathname/&gt;namefile.ext&quot;</dt>
<dd>директива служит для вкладывания
других файлов определений в основной файл проекта (ИБ) defcls.prm. В пути к
файлу может быть использован псевдоним, определенный в oxy.ini, относительный
путь или полный путь к файлу. Каталогом по умолчанию считается каталог ИБ.
Расширение файла может быть txt, prm - обычные текстовые файлы и ert - модуль
отчета 1С</dd>
<dt>#curmeth</dt>
<dd>директива выводит на экран текущий исполняемый метод класса и его
параметры с актуальными значениями и типами в месте появления данной
директивы. Примечание: в Defcls.prm данная директива отключена.</dd>
</dl>
</div>
<div class="section" id="c">
<h1>Отладка классов 1C++</h1>
<p>Для отладки модулей классов необходимо выполнить следующие действия:</p>
<ol class="arabic simple">
<li>В настройках компоненты 1С++ нажать кнопку &quot;Отладка;</li>
<li>Отладка возможна только для классов,
хранящихся во внешних ert-файлах или встроенных в конфигурацию в виде
обработок;</li>
<li>Если модуль класса расположен в текстовом файле, то следует сохранить
его в модуле отчета;</li>
<li>Форма отчета, в котором хранится модуль класса, обязана иметь хотя бы
один диалоговый элемент.</li>
</ol>
<!-- Attention: Рекомендуется в клиентском режиме 1С:Предприятия выключать режим "Отладки". -->
<p><strong>ВНИМАНИЕ: Рекомендуется в клиентском режиме 1С:Предприятия выключать режим &quot;Отладки&quot;.</strong></p>
<ol class="arabic simple" start="5">
<li>Возможна проблема: Глобальные объекты, созданные в режиме отладки, не дают закрыть 1С!</li>
</ol>
<pre class="literal-block">
Например, если в глобальном модуле написано
  Перем глОбъект;
  Процедура ПриНачалеРаботыСистемы()
      ЗагрузитьВнешнююКомпоненту(&quot;1cpp.dll&quot;);
      // а теперь включить режим отладки
        глОбъект = СоздатьОбъект(&quot;КОП&quot;);
      // объект создан в режиме отладки, его отладочная форма видна на экране
  КонецПроцедуры  // ПриНачалеРаботыСистемы

  После запуска такой конфигурации в режиме отладки
  1С невозможно закрыть стандартными средствами :(

  К сожалению, не помогает и явный сброс объекта
  Процедура ПриЗавершенииРаботыСистемы()
      глОбъект = 0;
  КонецПроцедуры  // ПриЗавершенииРаботыСистемы
  До этой процедуры дело просто не доходит :(

  Простой вариант решения в этом случае - спец. обработка, обнуляющая все глобальные объекты
</pre>
</div>
<div class="section" id="id47">
<h1>Настройка 1C++</h1>
<p>Настройка компоненты осуществляется с помощью настройки параметров 1С,
Сервис --&gt; Параметры ... --&gt; Закладка &quot;Настройка 1C++&quot;. Данная закладка появляется
только после загрузки компоненты методом 1С ЗагрузитьВнешнююКомпоненту.</p>
<p>На данной закладке присутствуют три флажка в виде кнопок: &quot;Проверка типов&quot; и
&quot;Оптимизация&quot;, &quot;Отладка&quot;:</p>
<ul class="simple">
<li><strong>Проверка</strong> типов включает строгую проверку типов во время выполнения
кода, при этом несколько увеличивается время вызова метода, в финальной
версии программного продукта рекомендуется отключать данную опцию;</li>
<li><strong>Оптимизация</strong> представляет собой метод &quot;отложенных вычислений&quot;,
который реализован в следующем виде: если в системе не разу не
инстанцировался (создавался экземпляр КОП) класс, то его реализация
(модуль КОП) не считывается с диска и не компилируется в P-код. При
первом создании объекта КОП происходит считывание с диска модуля и его
компиляция, далее откомпилированный модуль сохраняется в репозитории
модулей КОП, и в последующих созданиях объектов этапы по считыванию с
диска и компиляции не производятся. Данная оптимизация позволяет
существенно уменьшить время создания объектов КОП, за счет увеличения
объёма используемой памяти компьютера, что несущественно для данного
вида оптимизации. Это режим рекомендуется включать в финальной версии
продукта. При отключенной оптимизации при каждом создании объекта
происходит считывание с диска и компиляция модуля КОП, что позволяет
вносить изменения в модуль без закрытия/открытия 1С в режиме
1С:Предприятие. По аналогии с #LoadFromFile для модулей 1С.</li>
<li><strong>Отладка</strong> позволяет отлаживать в отладчике 1С модули классов, которые
хранятся в модулях отчетов. В финальной версии программного продукта
<strong>необходимо</strong> отключать данную опцию.</li>
</ul>
</div>
</div>
<div class="footer">
<hr class="footer" />
Generated on: 2013-01-30 23:09 UTC.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>

<!-- Mirrored from www.1cpp.ru/docum/icpp/html/classes.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 Mar 2024 08:56:55 GMT -->
</html>
